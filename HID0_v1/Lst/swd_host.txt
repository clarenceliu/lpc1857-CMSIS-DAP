; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\swd_host.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\obj\swd_host.d --cpu=Cortex-M3 --apcs=interwork -O3 -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\NXP\LPC18xx -D__MICROLIB --omf_browse=.\obj\swd_host.crf app\swd_host.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  swd_init PROC
;;;102    
;;;103    uint8_t swd_init(void) {
000000  b510              PUSH     {r4,lr}
;;;104        DAP_Setup();
000002  f7fffffe          BL       DAP_Setup
;;;105        PORT_SWD_SETUP();
;;;106        return 1;
000006  2001              MOVS     r0,#1
;;;107    }
000008  bd10              POP      {r4,pc}
;;;108    
                          ENDP

                  swd_read_dp PROC
;;;109    // Read debug port register.
;;;110    uint8_t swd_read_dp(uint8_t adr, uint32_t *val) {
00000a  b538              PUSH     {r3-r5,lr}
00000c  460c              MOV      r4,r1
;;;111        uint32_t tmp_in;
;;;112        uint8_t tmp_out[4];
;;;113        uint8_t ack;
;;;114    
;;;115        tmp_in = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(adr);
00000e  f000000c          AND      r0,r0,#0xc
000012  1c80              ADDS     r0,r0,#2
;;;116        ack = swd_transfer_retry(tmp_in, (uint32_t *)tmp_out);
000014  4669              MOV      r1,sp
000016  f7fffffe          BL       swd_transfer_retry
;;;117    
;;;118        *val = (tmp_out[3] << 24) | (tmp_out[2] << 16) | (tmp_out[1] << 8) | tmp_out[0];
00001a  f89d1000          LDRB     r1,[sp,#0]
00001e  f8dd2001          LDR      r2,[sp,#1]
;;;119    
;;;120        return (ack == 0x01);
000022  2801              CMP      r0,#1
000024  ea412102          ORR      r1,r1,r2,LSL #8       ;118
000028  6021              STR      r1,[r4,#0]
00002a  d000              BEQ      |L1.46|
00002c  2000              MOVS     r0,#0
                  |L1.46|
;;;121    }
00002e  bd38              POP      {r3-r5,pc}
;;;122    
                          ENDP

                  swd_write_dp PROC
;;;123    // Write debug port register
;;;124    uint8_t swd_write_dp(uint8_t adr, uint32_t val) {
000030  b538              PUSH     {r3-r5,lr}
;;;125        uint32_t req;
;;;126        uint8_t data[4];
;;;127        uint8_t ack;
;;;128    
;;;129        switch(adr) {
000032  2808              CMP      r0,#8
000034  d106              BNE      |L1.68|
;;;130            case DP_SELECT:
;;;131                if (dap_state.select == val)
000036  4afe              LDR      r2,|L1.1072|
000038  6813              LDR      r3,[r2,#0]  ; dap_state
00003a  428b              CMP      r3,r1
00003c  d101              BNE      |L1.66|
;;;132                    return 1;
00003e  2001              MOVS     r0,#1
                  |L1.64|
;;;133                dap_state.select = val;
;;;134                break;
;;;135            default:
;;;136                break;
;;;137        }
;;;138    
;;;139        req = SWD_REG_DP | SWD_REG_W | SWD_REG_ADR(adr);
;;;140        int2array(data, val, 4);
;;;141    
;;;142        ack = swd_transfer_retry(req, (uint32_t *)data);
;;;143    
;;;144        return (ack == 0x01);
;;;145    }
000040  bd38              POP      {r3-r5,pc}
                  |L1.66|
000042  6011              STR      r1,[r2,#0]            ;133  ; dap_state
                  |L1.68|
000044  f000040c          AND      r4,r0,#0xc            ;139
000048  2204              MOVS     r2,#4                 ;140
00004a  4668              MOV      r0,sp                 ;140
00004c  f7fffffe          BL       int2array
000050  4669              MOV      r1,sp                 ;142
000052  4620              MOV      r0,r4                 ;142
000054  f7fffffe          BL       swd_transfer_retry
000058  2801              CMP      r0,#1                 ;144
00005a  d0f1              BEQ      |L1.64|
00005c  2000              MOVS     r0,#0                 ;144
00005e  bd38              POP      {r3-r5,pc}
;;;146    
                          ENDP

                  swd_read_ap PROC
;;;147    // Read access port register.
;;;148    uint8_t swd_read_ap(uint32_t adr, uint32_t *val) {
000060  b538              PUSH     {r3-r5,lr}
000062  460d              MOV      r5,r1
000064  4604              MOV      r4,r0
;;;149        uint8_t tmp_in, ack;
;;;150        uint8_t tmp_out[4];
;;;151    
;;;152        uint32_t apsel = adr & 0xff000000;
000066  f000417f          AND      r1,r0,#0xff000000
;;;153        uint32_t bank_sel = adr & APBANKSEL;
00006a  f00000f0          AND      r0,r0,#0xf0
;;;154    
;;;155        if (!swd_write_dp(DP_SELECT, apsel | bank_sel)) {
00006e  4301              ORRS     r1,r1,r0
000070  2008              MOVS     r0,#8
000072  f7fffffe          BL       swd_write_dp
000076  2800              CMP      r0,#0
000078  d014              BEQ      |L1.164|
;;;156            return 0;
;;;157        }
;;;158    
;;;159        tmp_in = SWD_REG_AP | SWD_REG_R | SWD_REG_ADR(adr);
00007a  f004040c          AND      r4,r4,#0xc
00007e  1ce4              ADDS     r4,r4,#3
;;;160    
;;;161        // first dummy read
;;;162        swd_transfer_retry(tmp_in, (uint32_t *)tmp_out);
000080  4669              MOV      r1,sp
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       swd_transfer_retry
;;;163        ack = swd_transfer_retry(tmp_in, (uint32_t *)tmp_out);
000088  4669              MOV      r1,sp
00008a  4620              MOV      r0,r4
00008c  f7fffffe          BL       swd_transfer_retry
;;;164    
;;;165        *val = (tmp_out[3] << 24) | (tmp_out[2] << 16) | (tmp_out[1] << 8) | tmp_out[0];
000090  f89d1000          LDRB     r1,[sp,#0]
000094  f8dd2001          LDR      r2,[sp,#1]
;;;166    
;;;167        return (ack == 0x01);
000098  2801              CMP      r0,#1
00009a  ea412102          ORR      r1,r1,r2,LSL #8       ;165
00009e  6029              STR      r1,[r5,#0]
0000a0  d000              BEQ      |L1.164|
0000a2  2000              MOVS     r0,#0
                  |L1.164|
;;;168    }
0000a4  bd38              POP      {r3-r5,pc}
;;;169    
                          ENDP

                  swd_write_ap PROC
;;;170    // Write access port register
;;;171    uint8_t swd_write_ap(uint32_t adr, uint32_t val) {
0000a6  b538              PUSH     {r3-r5,lr}
0000a8  460d              MOV      r5,r1
0000aa  4604              MOV      r4,r0
;;;172        uint8_t data[4];
;;;173        uint8_t req, ack;
;;;174        uint32_t apsel = adr & 0xff000000;
0000ac  f000417f          AND      r1,r0,#0xff000000
;;;175        uint32_t bank_sel = adr & APBANKSEL;
0000b0  f00000f0          AND      r0,r0,#0xf0
;;;176    
;;;177        if (!swd_write_dp(DP_SELECT, apsel | bank_sel)) {
0000b4  4301              ORRS     r1,r1,r0
0000b6  2008              MOVS     r0,#8
0000b8  f7fffffe          BL       swd_write_dp
0000bc  2800              CMP      r0,#0
0000be  d005              BEQ      |L1.204|
;;;178            return 0;
;;;179        }
;;;180    
;;;181        switch(adr) {
0000c0  b934              CBNZ     r4,|L1.208|
;;;182            case AP_CSW:
;;;183                if (dap_state.csw == val)
0000c2  48db              LDR      r0,|L1.1072|
0000c4  6841              LDR      r1,[r0,#4]  ; dap_state
0000c6  42a9              CMP      r1,r5
0000c8  d101              BNE      |L1.206|
;;;184                    return 1;
0000ca  2001              MOVS     r0,#1
                  |L1.204|
;;;185                dap_state.csw = val;
;;;186                break;
;;;187            default:
;;;188                break;
;;;189        }
;;;190    
;;;191        req = SWD_REG_AP | SWD_REG_W | SWD_REG_ADR(adr);
;;;192        int2array(data, val, 4);
;;;193    
;;;194        if (swd_transfer_retry(req, (uint32_t *)data) != 0x01) {
;;;195            return 0;
;;;196        }
;;;197    
;;;198        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
;;;199        ack = swd_transfer_retry(req, NULL);
;;;200    
;;;201        return (ack == 0x01);
;;;202    }
0000cc  bd38              POP      {r3-r5,pc}
                  |L1.206|
0000ce  6045              STR      r5,[r0,#4]            ;185  ; dap_state
                  |L1.208|
0000d0  f004040c          AND      r4,r4,#0xc            ;191
0000d4  1c64              ADDS     r4,r4,#1              ;191
0000d6  2204              MOVS     r2,#4                 ;192
0000d8  4629              MOV      r1,r5                 ;192
0000da  4668              MOV      r0,sp                 ;192
0000dc  f7fffffe          BL       int2array
0000e0  4669              MOV      r1,sp                 ;194
0000e2  4620              MOV      r0,r4                 ;194
0000e4  f7fffffe          BL       swd_transfer_retry
0000e8  2801              CMP      r0,#1                 ;194
0000ea  d105              BNE      |L1.248|
0000ec  200e              MOVS     r0,#0xe               ;198
0000ee  2100              MOVS     r1,#0                 ;199
0000f0  f7fffffe          BL       swd_transfer_retry
0000f4  2801              CMP      r0,#1                 ;201
0000f6  d0e9              BEQ      |L1.204|
                  |L1.248|
0000f8  2000              MOVS     r0,#0                 ;201
0000fa  bd38              POP      {r3-r5,pc}
;;;203    
                          ENDP

                  swd_read_data PROC
;;;289    // Read target memory.
;;;290    static uint8_t swd_read_data(uint32_t addr, uint32_t *val) {
0000fc  b51c              PUSH     {r2-r4,lr}
0000fe  460c              MOV      r4,r1
;;;291        uint8_t tmp_in[4];
;;;292        uint8_t tmp_out[4];
;;;293        uint8_t req, ack;
;;;294    
;;;295        // put addr in TAR register
;;;296        int2array(tmp_in, addr, 4);
000100  4601              MOV      r1,r0
000102  2204              MOVS     r2,#4
000104  a801              ADD      r0,sp,#4
000106  f7fffffe          BL       int2array
;;;297        req = SWD_REG_AP | SWD_REG_W | (1 << 2);
00010a  2005              MOVS     r0,#5
;;;298        if (swd_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
00010c  a901              ADD      r1,sp,#4
00010e  f7fffffe          BL       swd_transfer_retry
000112  2801              CMP      r0,#1
000114  d112              BNE      |L1.316|
;;;299            return 0;
;;;300        }
;;;301    
;;;302        // read data
;;;303        req = SWD_REG_AP | SWD_REG_R | (3 << 2);
000116  200f              MOVS     r0,#0xf
;;;304        if (swd_transfer_retry(req, (uint32_t *)tmp_out) != 0x01) {
000118  4669              MOV      r1,sp
00011a  f7fffffe          BL       swd_transfer_retry
00011e  2801              CMP      r0,#1
000120  d10c              BNE      |L1.316|
;;;305            return 0;
;;;306        }
;;;307    
;;;308        // dummy read
;;;309        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
000122  200e              MOVS     r0,#0xe
;;;310        ack = swd_transfer_retry(req, (uint32_t *)tmp_out);
000124  4669              MOV      r1,sp
000126  f7fffffe          BL       swd_transfer_retry
;;;311    
;;;312        *val = (tmp_out[3] << 24) | (tmp_out[2] << 16) | (tmp_out[1] << 8) | tmp_out[0];
00012a  f89d1000          LDRB     r1,[sp,#0]
00012e  f8dd2001          LDR      r2,[sp,#1]
;;;313    
;;;314        return (ack == 0x01);
000132  2801              CMP      r0,#1
000134  ea412102          ORR      r1,r1,r2,LSL #8       ;312
000138  6021              STR      r1,[r4,#0]
00013a  d000              BEQ      |L1.318|
                  |L1.316|
00013c  2000              MOVS     r0,#0
                  |L1.318|
;;;315    }
00013e  bd1c              POP      {r2-r4,pc}
;;;316    
                          ENDP

                  swd_write_data PROC
;;;317    // Write target memory.
;;;318    static uint8_t swd_write_data(uint32_t address, uint32_t data) {
000140  b538              PUSH     {r3-r5,lr}
000142  460c              MOV      r4,r1
;;;319        uint8_t tmp_in[4];
;;;320        uint8_t req, ack;
;;;321    
;;;322        // put addr in TAR register
;;;323        int2array(tmp_in, address, 4);
000144  4601              MOV      r1,r0
000146  2204              MOVS     r2,#4
000148  4668              MOV      r0,sp
00014a  f7fffffe          BL       int2array
;;;324        req = SWD_REG_AP | SWD_REG_W | (1 << 2);
00014e  2005              MOVS     r0,#5
;;;325        if (swd_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
000150  4669              MOV      r1,sp
000152  f7fffffe          BL       swd_transfer_retry
000156  2801              CMP      r0,#1
000158  d110              BNE      |L1.380|
;;;326            return 0;
;;;327        }
;;;328    
;;;329        // write data
;;;330        int2array(tmp_in, data, 4);
00015a  2204              MOVS     r2,#4
00015c  4621              MOV      r1,r4
00015e  4668              MOV      r0,sp
000160  f7fffffe          BL       int2array
;;;331        req = SWD_REG_AP | SWD_REG_W | (3 << 2);
000164  200d              MOVS     r0,#0xd
;;;332        if (swd_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
000166  4669              MOV      r1,sp
000168  f7fffffe          BL       swd_transfer_retry
00016c  2801              CMP      r0,#1
00016e  d105              BNE      |L1.380|
;;;333            return 0;
;;;334        }
;;;335    
;;;336        // dummy read
;;;337        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
000170  200e              MOVS     r0,#0xe
;;;338        ack = swd_transfer_retry(req, NULL);
000172  2100              MOVS     r1,#0
000174  f7fffffe          BL       swd_transfer_retry
;;;339    
;;;340        return (ack == 0x01) ? 1 : 0;
000178  2801              CMP      r0,#1
00017a  d000              BEQ      |L1.382|
                  |L1.380|
00017c  2000              MOVS     r0,#0
                  |L1.382|
;;;341    }
00017e  bd38              POP      {r3-r5,pc}
;;;342    
                          ENDP

                  swd_read_byte PROC
;;;369    // Read 8-bit byte from target memory.
;;;370    static uint8_t swd_read_byte(uint32_t addr, uint8_t *val) {
000180  b538              PUSH     {r3-r5,lr}
000182  460c              MOV      r4,r1
000184  4605              MOV      r5,r0
;;;371        uint32_t tmp;
;;;372        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE8)) {
000186  49ab              LDR      r1,|L1.1076|
000188  2000              MOVS     r0,#0
00018a  f7fffffe          BL       swd_write_ap
00018e  2800              CMP      r0,#0
000190  d00b              BEQ      |L1.426|
;;;373            return 0;
;;;374        }
;;;375    
;;;376        if (!swd_read_data(addr, &tmp)) {
000192  4669              MOV      r1,sp
000194  4628              MOV      r0,r5
000196  f7fffffe          BL       swd_read_data
00019a  2800              CMP      r0,#0
00019c  d005              BEQ      |L1.426|
;;;377            return 0;
;;;378        }
;;;379    
;;;380        *val = (uint8_t)(tmp >> ((addr & 0x03) << 3));
00019e  07a8              LSLS     r0,r5,#30
0001a0  0ec1              LSRS     r1,r0,#27
0001a2  9800              LDR      r0,[sp,#0]
0001a4  40c8              LSRS     r0,r0,r1
0001a6  7020              STRB     r0,[r4,#0]
;;;381        return 1;
0001a8  2001              MOVS     r0,#1
                  |L1.426|
;;;382    }
0001aa  bd38              POP      {r3-r5,pc}
;;;383    
                          ENDP

                  swd_read_memory PROC
;;;401    // size is in bytes.
;;;402    uint8_t swd_read_memory(uint32_t address, uint8_t *data, uint32_t size) {
0001ac  e92d41f0          PUSH     {r4-r8,lr}
0001b0  4614              MOV      r4,r2
0001b2  460f              MOV      r7,r1
0001b4  4605              MOV      r5,r0
;;;403        uint32_t n;
;;;404    
;;;405        // Read bytes until word aligned
;;;406        while ((size > 0) && (address & 0x3)) {
;;;407            if (!swd_read_byte(address, data)) {
;;;408                return 0;
;;;409            }
;;;410            address++;
;;;411            data++;
;;;412            size--;
0001b6  e008              B        |L1.458|
                  |L1.440|
0001b8  4639              MOV      r1,r7                 ;407
0001ba  4628              MOV      r0,r5                 ;407
0001bc  f7fffffe          BL       swd_read_byte
0001c0  2800              CMP      r0,#0                 ;407
0001c2  d028              BEQ      |L1.534|
0001c4  1c6d              ADDS     r5,r5,#1              ;410
0001c6  1c7f              ADDS     r7,r7,#1              ;411
0001c8  1e64              SUBS     r4,r4,#1
                  |L1.458|
0001ca  b31c              CBZ      r4,|L1.532|
0001cc  07a8              LSLS     r0,r5,#30             ;406
0001ce  d1f3              BNE      |L1.440|
0001d0  e012              B        |L1.504|
;;;413        }
;;;414    
;;;415        // Read word aligned blocks
;;;416        while (size > 3) {
;;;417            // Limit to auto increment page size
;;;418            n = TARGET_AUTO_INCREMENT_PAGE_SIZE - (address & (TARGET_AUTO_INCREMENT_PAGE_SIZE - 1));
0001d2  bf00              NOP      
                  |L1.468|
0001d4  f3c5000b          UBFX     r0,r5,#0,#12
0001d8  f5c05680          RSB      r6,r0,#0x1000
;;;419            if (size < n) {
0001dc  42b4              CMP      r4,r6
0001de  d201              BCS      |L1.484|
;;;420                n = size & 0xFFFFFFFC; // Only count complete words remaining
0001e0  f0240603          BIC      r6,r4,#3
                  |L1.484|
;;;421            }
;;;422    
;;;423            if (!swd_read_block(address, data, n)) {
0001e4  4632              MOV      r2,r6
0001e6  4639              MOV      r1,r7
0001e8  4628              MOV      r0,r5
0001ea  f7fffffe          BL       swd_read_block
0001ee  2800              CMP      r0,#0
0001f0  d011              BEQ      |L1.534|
;;;424                return 0;
;;;425            }
;;;426    
;;;427            address += n;
0001f2  4435              ADD      r5,r5,r6
;;;428            data += n;
0001f4  4437              ADD      r7,r7,r6
;;;429            size -= n;
0001f6  1ba4              SUBS     r4,r4,r6
                  |L1.504|
0001f8  2c03              CMP      r4,#3                 ;416
0001fa  d8eb              BHI      |L1.468|
0001fc  e008              B        |L1.528|
                  |L1.510|
;;;430        }
;;;431    
;;;432        // Read remaining bytes
;;;433        while (size > 0) {
;;;434            if (!swd_read_byte(address, data)) {
0001fe  4639              MOV      r1,r7
000200  4628              MOV      r0,r5
000202  f7fffffe          BL       swd_read_byte
000206  2800              CMP      r0,#0
000208  d005              BEQ      |L1.534|
;;;435                return 0;
;;;436            }
;;;437            address++;
00020a  1c6d              ADDS     r5,r5,#1
;;;438            data++;
00020c  1c7f              ADDS     r7,r7,#1
;;;439            size--;
00020e  1e64              SUBS     r4,r4,#1
                  |L1.528|
000210  2c00              CMP      r4,#0                 ;433
000212  d1f4              BNE      |L1.510|
                  |L1.532|
;;;440        }
;;;441    
;;;442        return 1;
000214  2001              MOVS     r0,#1
                  |L1.534|
;;;443    }
000216  e8bd81f0          POP      {r4-r8,pc}
;;;444    
                          ENDP

                  swd_write_memory PROC
;;;446    // size is in bytes.
;;;447    uint8_t swd_write_memory(uint32_t address, uint8_t *data, uint32_t size) {
00021a  e92d41f0          PUSH     {r4-r8,lr}
00021e  4614              MOV      r4,r2
000220  460e              MOV      r6,r1
000222  4605              MOV      r5,r0
;;;448        uint32_t n;
;;;449        // Write bytes until word aligned
;;;450        while ((size > 0) && (address & 0x3)) {
;;;451            if (!swd_write_byte(address, *data)) {
;;;452                return 0;
;;;453            }
;;;454            address++;
;;;455            data++;
;;;456            size--;
000224  e008              B        |L1.568|
                  |L1.550|
000226  7831              LDRB     r1,[r6,#0]            ;451
000228  4628              MOV      r0,r5                 ;451
00022a  f7fffffe          BL       swd_write_byte
00022e  2800              CMP      r0,#0                 ;451
000230  d0f1              BEQ      |L1.534|
000232  1c6d              ADDS     r5,r5,#1              ;454
000234  1c76              ADDS     r6,r6,#1              ;455
000236  1e64              SUBS     r4,r4,#1
                  |L1.568|
000238  b314              CBZ      r4,|L1.640|
00023a  07a8              LSLS     r0,r5,#30             ;450
00023c  d1f3              BNE      |L1.550|
00023e  e011              B        |L1.612|
                  |L1.576|
;;;457        }
;;;458    
;;;459        // Write word aligned blocks
;;;460        while (size > 3) {
;;;461            // Limit to auto increment page size
;;;462            n = TARGET_AUTO_INCREMENT_PAGE_SIZE - (address & (TARGET_AUTO_INCREMENT_PAGE_SIZE - 1));
000240  f3c5000b          UBFX     r0,r5,#0,#12
000244  f5c05780          RSB      r7,r0,#0x1000
;;;463            if (size < n) {
000248  42bc              CMP      r4,r7
00024a  d201              BCS      |L1.592|
;;;464                n = size & 0xFFFFFFFC; // Only count complete words remaining
00024c  f0240703          BIC      r7,r4,#3
                  |L1.592|
;;;465            }
;;;466    
;;;467            if (!swd_write_block(address, data, n)) {
000250  463a              MOV      r2,r7
000252  4631              MOV      r1,r6
000254  4628              MOV      r0,r5
000256  f7fffffe          BL       swd_write_block
00025a  2800              CMP      r0,#0
00025c  d0db              BEQ      |L1.534|
;;;468                return 0;
;;;469            }
;;;470    
;;;471            address += n;
00025e  443d              ADD      r5,r5,r7
;;;472            data += n;
000260  443e              ADD      r6,r6,r7
;;;473            size -= n;
000262  1be4              SUBS     r4,r4,r7
                  |L1.612|
000264  2c03              CMP      r4,#3                 ;460
000266  d8eb              BHI      |L1.576|
000268  e008              B        |L1.636|
                  |L1.618|
;;;474        }
;;;475    
;;;476        // Write remaining bytes
;;;477        while (size > 0) {
;;;478            if (!swd_write_byte(address, *data)) {
00026a  7831              LDRB     r1,[r6,#0]
00026c  4628              MOV      r0,r5
00026e  f7fffffe          BL       swd_write_byte
000272  2800              CMP      r0,#0
000274  d0cf              BEQ      |L1.534|
;;;479                return 0;
;;;480            }
;;;481            address++;
000276  1c6d              ADDS     r5,r5,#1
;;;482            data++;
000278  1c76              ADDS     r6,r6,#1
;;;483            size--;
00027a  1e64              SUBS     r4,r4,#1
                  |L1.636|
00027c  2c00              CMP      r4,#0                 ;477
00027e  d1f4              BNE      |L1.618|
                  |L1.640|
;;;484        }
;;;485    
;;;486        return 1;
000280  2001              MOVS     r0,#1
;;;487    }
000282  e7c8              B        |L1.534|
;;;488    
                          ENDP

                  swd_write_core_register PROC
;;;565    
;;;566    static uint8_t swd_write_core_register(uint32_t n, uint32_t val) {
000284  b573              PUSH     {r0,r1,r4-r6,lr}
000286  4606              MOV      r6,r0
;;;567        int i = 0, timeout = 100;
000288  2400              MOVS     r4,#0
00028a  2564              MOVS     r5,#0x64
;;;568        if (!swd_write_word(DCRDR, val))
00028c  486a              LDR      r0,|L1.1080|
00028e  9901              LDR      r1,[sp,#4]
000290  f7fffffe          BL       swd_write_word
000294  2800              CMP      r0,#0
000296  d013              BEQ      |L1.704|
;;;569            return 0;
;;;570    
;;;571        if (!swd_write_word(DCRSR, n | REGWnR)) {
000298  4867              LDR      r0,|L1.1080|
00029a  f4463180          ORR      r1,r6,#0x10000
00029e  1f00              SUBS     r0,r0,#4
0002a0  f7fffffe          BL       swd_write_word
0002a4  2800              CMP      r0,#0
0002a6  d00b              BEQ      |L1.704|
;;;572            return 0;
;;;573        }
;;;574    
;;;575        // wait for S_REGRDY
;;;576        for (i = 0; i < timeout; i++) {
;;;577    
;;;578            if (!swd_read_word(DHCSR, &val)) {
0002a8  4e63              LDR      r6,|L1.1080|
0002aa  3e08              SUBS     r6,r6,#8
                  |L1.684|
0002ac  a901              ADD      r1,sp,#4
0002ae  4630              MOV      r0,r6
0002b0  f7fffffe          BL       swd_read_word
0002b4  2800              CMP      r0,#0
0002b6  d003              BEQ      |L1.704|
;;;579                return 0;
;;;580            }
;;;581    
;;;582            if (val & S_REGRDY) {
0002b8  9801              LDR      r0,[sp,#4]
0002ba  03c0              LSLS     r0,r0,#15
0002bc  d501              BPL      |L1.706|
;;;583                return 1;
0002be  2001              MOVS     r0,#1
                  |L1.704|
;;;584            }
;;;585        }
;;;586    
;;;587        return 0;
;;;588    }
0002c0  bd7c              POP      {r2-r6,pc}
                  |L1.706|
0002c2  1c64              ADDS     r4,r4,#1              ;576
0002c4  42ac              CMP      r4,r5                 ;576
0002c6  dbf1              BLT      |L1.684|
0002c8  2000              MOVS     r0,#0                 ;587
0002ca  bd7c              POP      {r2-r6,pc}
;;;589    
                          ENDP

                  swd_read_core_register PROC
;;;536    
;;;537    static uint8_t swd_read_core_register(uint32_t n, uint32_t *val) {
0002cc  e92d41f0          PUSH     {r4-r8,lr}
0002d0  460e              MOV      r6,r1
;;;538        int i = 0, timeout = 100;
;;;539        if (!swd_write_word(DCRSR, n)) {
0002d2  4601              MOV      r1,r0
0002d4  4858              LDR      r0,|L1.1080|
0002d6  2400              MOVS     r4,#0                 ;538
0002d8  2564              MOVS     r5,#0x64              ;538
0002da  1f00              SUBS     r0,r0,#4
0002dc  f7fffffe          BL       swd_write_word
0002e0  2800              CMP      r0,#0
0002e2  d098              BEQ      |L1.534|
;;;540            return 0;
;;;541        }
;;;542    
;;;543        // wait for S_REGRDY
;;;544        for (i = 0; i < timeout; i++) {
;;;545    
;;;546            if (!swd_read_word(DHCSR, val)) {
0002e4  4f54              LDR      r7,|L1.1080|
0002e6  3f08              SUBS     r7,r7,#8
                  |L1.744|
0002e8  4631              MOV      r1,r6
0002ea  4638              MOV      r0,r7
0002ec  f7fffffe          BL       swd_read_word
0002f0  2800              CMP      r0,#0
0002f2  d090              BEQ      |L1.534|
;;;547                return 0;
;;;548            }
;;;549    
;;;550            if (*val & S_REGRDY) {
0002f4  6830              LDR      r0,[r6,#0]
0002f6  03c0              LSLS     r0,r0,#15
0002f8  d402              BMI      |L1.768|
0002fa  1c64              ADDS     r4,r4,#1              ;544
0002fc  42ac              CMP      r4,r5                 ;544
0002fe  dbf3              BLT      |L1.744|
                  |L1.768|
;;;551                break;
;;;552            }
;;;553        }
;;;554    
;;;555        if (i == timeout) {
000300  42ac              CMP      r4,r5
000302  d101              BNE      |L1.776|
;;;556            return 0;
000304  2000              MOVS     r0,#0
;;;557        }
;;;558    
;;;559        if (!swd_read_word(DCRDR, val)) {
;;;560            return 0;
;;;561        }
;;;562    
;;;563        return 1;
;;;564    }
000306  e786              B        |L1.534|
                  |L1.776|
000308  4631              MOV      r1,r6                 ;559
00030a  484b              LDR      r0,|L1.1080|
00030c  f7fffffe          BL       swd_read_word
000310  2800              CMP      r0,#0                 ;559
000312  d080              BEQ      |L1.534|
000314  2001              MOVS     r0,#1                 ;563
000316  e77e              B        |L1.534|
;;;565    
                          ENDP

                  swd_is_semihost_event PROC
;;;589    
;;;590    uint8_t swd_is_semihost_event(uint32_t *r0, uint32_t *r1) {
000318  b538              PUSH     {r3-r5,lr}
00031a  4605              MOV      r5,r0
;;;591        uint32_t val;
;;;592    
;;;593        if (!swd_read_word(DBG_HCSR, &val)) {
00031c  4846              LDR      r0,|L1.1080|
00031e  460c              MOV      r4,r1                 ;590
000320  4669              MOV      r1,sp
000322  3808              SUBS     r0,r0,#8
000324  f7fffffe          BL       swd_read_word
000328  2800              CMP      r0,#0
00032a  d003              BEQ      |L1.820|
;;;594            return 0;
;;;595        }
;;;596    
;;;597        // Not hit breakpoint
;;;598        if ((val & S_HALT) == 0) {
00032c  9800              LDR      r0,[sp,#0]
00032e  0380              LSLS     r0,r0,#14
000330  d401              BMI      |L1.822|
;;;599            return 0;
000332  2000              MOVS     r0,#0
                  |L1.820|
;;;600        }
;;;601    
;;;602        // Has hit breakpoint
;;;603        // Read r0 and r1
;;;604        if (!swd_read_core_register(0, r0)) {
;;;605            return 0;
;;;606        }
;;;607    
;;;608        if (!swd_read_core_register(1, r1)) {
;;;609            return 0;
;;;610        }
;;;611    
;;;612        return 1;
;;;613    }
000334  bd38              POP      {r3-r5,pc}
                  |L1.822|
000336  4629              MOV      r1,r5                 ;604
000338  2000              MOVS     r0,#0                 ;604
00033a  f7fffffe          BL       swd_read_core_register
00033e  2800              CMP      r0,#0                 ;604
000340  d0f8              BEQ      |L1.820|
000342  4621              MOV      r1,r4                 ;608
000344  2001              MOVS     r0,#1                 ;608
000346  f7fffffe          BL       swd_read_core_register
00034a  2800              CMP      r0,#0                 ;608
00034c  d0f2              BEQ      |L1.820|
00034e  2001              MOVS     r0,#1                 ;612
000350  bd38              POP      {r3-r5,pc}
;;;614    
                          ENDP

                  swd_semihost_restart PROC
;;;631    // Restart target after BKPT
;;;632    uint8_t swd_semihost_restart(uint32_t r0) {
000352  b508              PUSH     {r3,lr}
;;;633        uint32_t pc;
;;;634    
;;;635        // Update r0
;;;636        if (!swd_write_core_register(0, r0)) {
000354  4601              MOV      r1,r0
000356  2000              MOVS     r0,#0
000358  f7fffffe          BL       swd_write_core_register
00035c  2800              CMP      r0,#0
00035e  d014              BEQ      |L1.906|
;;;637            return 0;
;;;638        }
;;;639    
;;;640        // Update PC
;;;641        if (!swd_read_core_register(15, &pc)) {
000360  4669              MOV      r1,sp
000362  200f              MOVS     r0,#0xf
000364  f7fffffe          BL       swd_read_core_register
000368  2800              CMP      r0,#0
00036a  d00e              BEQ      |L1.906|
;;;642            return 0;
;;;643        }
;;;644    
;;;645        if (!swd_write_core_register(15, pc + 2)) {
00036c  9900              LDR      r1,[sp,#0]
00036e  200f              MOVS     r0,#0xf
000370  1c89              ADDS     r1,r1,#2
000372  f7fffffe          BL       swd_write_core_register
000376  2800              CMP      r0,#0
000378  d007              BEQ      |L1.906|
;;;646            return 0;
;;;647        }
;;;648    
;;;649        // Restart
;;;650        if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN)) {
00037a  482f              LDR      r0,|L1.1080|
00037c  492f              LDR      r1,|L1.1084|
00037e  3808              SUBS     r0,r0,#8
000380  f7fffffe          BL       swd_write_word
000384  2800              CMP      r0,#0
000386  d000              BEQ      |L1.906|
;;;651            return 0;
;;;652        }
;;;653    
;;;654        return 1;
000388  2001              MOVS     r0,#1
                  |L1.906|
;;;655    }
00038a  bd08              POP      {r3,pc}
;;;656    
                          ENDP

                  swd_flash_syscall_exec PROC
;;;657    uint8_t swd_flash_syscall_exec(const FLASH_SYSCALL *sysCallParam, uint32_t entry, uint32_t arg1, uint32_t arg2, uint32_t arg3, uint32_t arg4) {
00038c  b570              PUSH     {r4-r6,lr}
00038e  b092              SUB      sp,sp,#0x48
;;;658        DEBUG_STATE state;
;;;659    
;;;660        // Call flash algorithm function on target and wait for result.
;;;661        state.xpsr     = 0x01000000;          // xPSR: T = 1, ISR = 0
000390  f04f7680          MOV      r6,#0x1000000
000394  e9dd4516          LDRD     r4,r5,[sp,#0x58]      ;657
000398  9610              STR      r6,[sp,#0x40]
00039a  e88d003c          STM      sp,{r2-r5}
;;;662        state.r[0]     = arg1;                   // R0: Argument 1
;;;663        state.r[1]     = arg2;                   // R1: Argument 2
;;;664        state.r[2]     = arg3;                   // R2: Argument 3
;;;665        state.r[3]     = arg4;                   // R3: Argument 4
;;;666    
;;;667        state.r[9]     = sysCallParam->static_base;    // SB: Static Base
00039e  6842              LDR      r2,[r0,#4]
;;;668    
;;;669        state.r[13]    = sysCallParam->stack_pointer;  // SP: Stack Pointer
0003a0  9209              STR      r2,[sp,#0x24]
0003a2  6882              LDR      r2,[r0,#8]
;;;670        state.r[14]    = sysCallParam->breakpoint;       // LR: Exit Point
0003a4  920d              STR      r2,[sp,#0x34]
0003a6  6800              LDR      r0,[r0,#0]
0003a8  e9cd010e          STRD     r0,r1,[sp,#0x38]
;;;671        state.r[15]    = entry;                           // PC: Entry Point
;;;672    
;;;673        if (!swd_write_debug_state(&state)) {
0003ac  4668              MOV      r0,sp
0003ae  f7fffffe          BL       swd_write_debug_state
0003b2  2800              CMP      r0,#0
0003b4  d015              BEQ      |L1.994|
0003b6  4e20              LDR      r6,|L1.1080|
0003b8  2400              MOVS     r4,#0
0003ba  f2427510          MOV      r5,#0x2710
0003be  3e08              SUBS     r6,r6,#8
                  |L1.960|
0003c0  a911              ADD      r1,sp,#0x44
0003c2  4630              MOV      r0,r6
0003c4  f7fffffe          BL       swd_read_word
0003c8  b150              CBZ      r0,|L1.992|
0003ca  9811              LDR      r0,[sp,#0x44]
0003cc  0380              LSLS     r0,r0,#14
0003ce  d50a              BPL      |L1.998|
;;;674            return 0;
;;;675        }
;;;676    
;;;677        if (!swd_wait_until_halted()) {
;;;678            return 0;
;;;679        }
;;;680    
;;;681        if (!swd_read_core_register(0, &state.r[0])) {
0003d0  4669              MOV      r1,sp
0003d2  2000              MOVS     r0,#0
0003d4  f7fffffe          BL       swd_read_core_register
0003d8  2800              CMP      r0,#0
0003da  d002              BEQ      |L1.994|
;;;682            return 0;
;;;683        }
;;;684    
;;;685        // Flash functions return 0 if successful.
;;;686        if (state.r[0] != 0) {
0003dc  9800              LDR      r0,[sp,#0]
0003de  b130              CBZ      r0,|L1.1006|
                  |L1.992|
;;;687            return 0;
0003e0  2000              MOVS     r0,#0
                  |L1.994|
;;;688        }
;;;689    
;;;690        return 1;
;;;691    }
0003e2  b012              ADD      sp,sp,#0x48
0003e4  bd70              POP      {r4-r6,pc}
                  |L1.998|
0003e6  1c64              ADDS     r4,r4,#1
0003e8  42ac              CMP      r4,r5
0003ea  d3e9              BCC      |L1.960|
0003ec  e7f8              B        |L1.992|
                  |L1.1006|
0003ee  2001              MOVS     r0,#1                 ;690
0003f0  e7f7              B        |L1.994|
;;;692    
                          ENDP

                  JTAG2SWD PROC
;;;736    
;;;737    static uint8_t JTAG2SWD() {
0003f2  b51c              PUSH     {r2-r4,lr}
;;;738        uint32_t tmp = 0;
;;;739    
;;;740        if (!swd_reset()) {
0003f4  f7fffffe          BL       swd_reset
0003f8  2800              CMP      r0,#0
0003fa  d024              BEQ      |L1.1094|
0003fc  209e              MOVS     r0,#0x9e
0003fe  f88d0000          STRB     r0,[sp,#0]
000402  20e7              MOVS     r0,#0xe7
000404  f88d0001          STRB     r0,[sp,#1]
000408  4669              MOV      r1,sp
00040a  2010              MOVS     r0,#0x10
00040c  f7fffffe          BL       SWJ_Sequence
;;;741            return 0;
;;;742        }
;;;743    
;;;744        if (!swd_switch(0xE79E)) {
;;;745            return 0;
;;;746        }
;;;747    
;;;748        if (!swd_reset()) {
000410  f7fffffe          BL       swd_reset
000414  2800              CMP      r0,#0                 ;744
000416  d016              BEQ      |L1.1094|
000418  2000              MOVS     r0,#0                 ;744
00041a  f88d0000          STRB     r0,[sp,#0]            ;744
00041e  4669              MOV      r1,sp                 ;744
000420  2008              MOVS     r0,#8                 ;744
000422  f7fffffe          BL       SWJ_Sequence
000426  a901              ADD      r1,sp,#4              ;744
000428  2000              MOVS     r0,#0                 ;744
00042a  f7fffffe          BL       swd_read_dp
00042e  e007              B        |L1.1088|
                  |L1.1072|
                          DCD      ||.data||
                  |L1.1076|
                          DCD      0x23000050
                  |L1.1080|
                          DCD      0xe000edf8
                  |L1.1084|
                          DCD      0xa05f0001
                  |L1.1088|
000440  2801              CMP      r0,#1                 ;744
000442  d000              BEQ      |L1.1094|
;;;749            return 0;
;;;750        }
;;;751    
;;;752        if (!swd_read_idcode(&tmp)) {
;;;753            return 0;
000444  2000              MOVS     r0,#0
                  |L1.1094|
;;;754        }
;;;755    
;;;756        return 1;
;;;757    }
000446  bd1c              POP      {r2-r4,pc}
;;;758    
                          ENDP

                  swd_init_debug PROC
;;;759    static uint8_t swd_init_debug(void) {
000448  b538              PUSH     {r3-r5,lr}
;;;760        uint32_t tmp = 0;
00044a  2000              MOVS     r0,#0
;;;761    
;;;762        // init dap state with fake values
;;;763        dap_state.select = 0xffffffff;
00044c  49d4              LDR      r1,|L1.1952|
00044e  9000              STR      r0,[sp,#0]
000450  1e40              SUBS     r0,r0,#1
;;;764        dap_state.csw = 0xffffffff;
000452  6008              STR      r0,[r1,#0]  ; dap_state
;;;765    
;;;766        DAP_Setup();
000454  6048              STR      r0,[r1,#4]  ; dap_state
000456  f7fffffe          BL       DAP_Setup
;;;767        PORT_SWD_SETUP();
;;;768    
;;;769        // call a target dependant function
;;;770        // this function can do several stuff before really
;;;771        // initing the debug
;;;772        target_before_init_debug();
00045a  f7fffffe          BL       target_before_init_debug
;;;773    
;;;774        if (!JTAG2SWD()) {
00045e  f7fffffe          BL       JTAG2SWD
000462  2800              CMP      r0,#0
000464  d02d              BEQ      |L1.1218|
;;;775            return 0;
;;;776        }
;;;777    
;;;778        if (!swd_write_dp(DP_ABORT, STKCMPCLR | STKERRCLR | WDERRCLR | ORUNERRCLR)) {
000466  211e              MOVS     r1,#0x1e
000468  2000              MOVS     r0,#0
00046a  f7fffffe          BL       swd_write_dp
00046e  2800              CMP      r0,#0
000470  d027              BEQ      |L1.1218|
;;;779            return 0;
;;;780        }
;;;781    
;;;782        // Ensure CTRL/STAT register selected in DPBANKSEL
;;;783        if (!swd_write_dp(DP_SELECT, 0)) {
000472  2100              MOVS     r1,#0
000474  2008              MOVS     r0,#8
000476  f7fffffe          BL       swd_write_dp
00047a  2800              CMP      r0,#0
00047c  d021              BEQ      |L1.1218|
;;;784            return 0;
;;;785        }
;;;786    
;;;787        // Power up
;;;788        if (!swd_write_dp(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ)) {
00047e  f04f41a0          MOV      r1,#0x50000000
000482  2004              MOVS     r0,#4
000484  f7fffffe          BL       swd_write_dp
000488  2800              CMP      r0,#0
00048a  d01a              BEQ      |L1.1218|
;;;789            return 0;
;;;790        }
;;;791    
;;;792        do {
;;;793            if (!swd_read_dp(DP_CTRL_STAT, &tmp)) {
;;;794                return 0;
;;;795            }
;;;796        } while ((tmp & (CDBGPWRUPACK | CSYSPWRUPACK)) != (CDBGPWRUPACK | CSYSPWRUPACK));
00048c  f04f4420          MOV      r4,#0xa0000000
                  |L1.1168|
000490  4669              MOV      r1,sp                 ;793
000492  2004              MOVS     r0,#4                 ;793
000494  f7fffffe          BL       swd_read_dp
000498  2800              CMP      r0,#0                 ;793
00049a  d012              BEQ      |L1.1218|
00049c  9800              LDR      r0,[sp,#0]
00049e  ea340000          BICS     r0,r4,r0
0004a2  d1f5              BNE      |L1.1168|
;;;797    
;;;798        if (!swd_write_dp(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ | TRNNORMAL | MASKLANE)) {
0004a4  49bf              LDR      r1,|L1.1956|
0004a6  2004              MOVS     r0,#4
0004a8  f7fffffe          BL       swd_write_dp
0004ac  2800              CMP      r0,#0
0004ae  d008              BEQ      |L1.1218|
;;;799            return 0;
;;;800        }
;;;801    
;;;802        // call a target dependant function:
;;;803        // some target can enter in a lock state
;;;804        // this function can unlock these targets
;;;805        target_unlock_sequence();
0004b0  f7fffffe          BL       target_unlock_sequence
;;;806    
;;;807        if (!swd_write_dp(DP_SELECT, 0)) {
0004b4  2100              MOVS     r1,#0
0004b6  2008              MOVS     r0,#8
0004b8  f7fffffe          BL       swd_write_dp
0004bc  2800              CMP      r0,#0
0004be  d000              BEQ      |L1.1218|
;;;808            return 0;
;;;809        }
;;;810    
;;;811        return 1;
0004c0  2001              MOVS     r0,#1
                  |L1.1218|
;;;812    }
0004c2  bd38              POP      {r3-r5,pc}
;;;813    
                          ENDP

                  swd_set_target_reset PROC
;;;814    
;;;815    void swd_set_target_reset(uint8_t asserted) {
0004c4  4770              BX       lr
;;;816        if (asserted) {
;;;817            PIN_nRESET_OUT(1);
;;;818        } else {
;;;819            PIN_nRESET_OUT(0);
;;;820        }
;;;821    }
;;;822    
                          ENDP

                  swd_set_target_state PROC
;;;823    uint8_t swd_set_target_state(TARGET_RESET_STATE state) {
0004c6  b538              PUSH     {r3-r5,lr}
;;;824        uint32_t val;
;;;825        switch (state) {
;;;826            case RESET_HOLD:
;;;827                swd_set_target_reset(1);
;;;828                break;
;;;829    
;;;830            case RESET_RUN:
;;;831                swd_set_target_reset(1);
;;;832                Delayms(2);
;;;833    
;;;834                swd_set_target_reset(0);
;;;835                Delayms(2);
;;;836                break;
;;;837    
;;;838            case RESET_RUN_WITH_DEBUG:
;;;839                // First reset
;;;840                swd_set_target_reset(1);
;;;841                Delayms(1);
;;;842    
;;;843                swd_set_target_reset(0);
;;;844                Delayms(1);
;;;845    
;;;846                if (!swd_init_debug()) {
;;;847                    return 0;
;;;848                }
;;;849    
;;;850                // Enable debug (for semihost)
;;;851                if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN)) {
0004c8  4db7              LDR      r5,|L1.1960|
0004ca  4cb8              LDR      r4,|L1.1964|
0004cc  2806              CMP      r0,#6                 ;825
0004ce  d268              BCS      |L1.1442|
0004d0  e8dff000          TBB      [pc,r0]               ;825
0004d4  651f0308          DCB      0x65,0x1f,0x03,0x08
0004d8  4346              DCB      0x43,0x46
0004da  2002              MOVS     r0,#2                 ;832
0004dc  f7fffffe          BL       Delayms
0004e0  2002              MOVS     r0,#2                 ;835
0004e2  e013              B        |L1.1292|
0004e4  2001              MOVS     r0,#1                 ;841
0004e6  f7fffffe          BL       Delayms
0004ea  2001              MOVS     r0,#1                 ;844
0004ec  f7fffffe          BL       Delayms
0004f0  f7fffffe          BL       swd_init_debug
0004f4  2800              CMP      r0,#0                 ;846
0004f6  d053              BEQ      |L1.1440|
0004f8  4629              MOV      r1,r5
0004fa  4620              MOV      r0,r4
0004fc  f7fffffe          BL       swd_write_word
000500  2800              CMP      r0,#0
000502  d04d              BEQ      |L1.1440|
;;;852                    return 0;
;;;853                }
;;;854    
;;;855                // Reset again
;;;856                swd_set_target_reset(1);
;;;857                Delayms(1);
000504  2001              MOVS     r0,#1
000506  f7fffffe          BL       Delayms
;;;858    
;;;859                swd_set_target_reset(0);
;;;860                Delayms(1);
00050a  2001              MOVS     r0,#1
                  |L1.1292|
00050c  f7fffffe          BL       Delayms
000510  e045              B        |L1.1438|
;;;861                break;
;;;862    
;;;863            case RESET_PROGRAM:
;;;864    #if !defined(SOFT_RESET)
;;;865                // Use hardware reset (HW RESET)
;;;866                // First reset
;;;867    //            swd_set_target_reset(1);
;;;868    //            Delayms(2000);
;;;869    //
;;;870    //            swd_set_target_reset(0);
;;;871    //            Delayms(2000);
;;;872    
;;;873                if (!swd_init_debug()) {
000512  f7fffffe          BL       swd_init_debug
000516  2800              CMP      r0,#0
000518  d042              BEQ      |L1.1440|
;;;874                    return 0;
;;;875                }
;;;876    
;;;877                // Enable debug
;;;878                if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN)) {
00051a  4629              MOV      r1,r5
00051c  4620              MOV      r0,r4
00051e  f7fffffe          BL       swd_write_word
000522  2800              CMP      r0,#0
000524  d03c              BEQ      |L1.1440|
;;;879                    return 0;
;;;880                }
;;;881    
;;;882                // Enable halt on reset
;;;883                if (!swd_write_word(DBG_EMCR, VC_CORERESET)) {
000526  4da1              LDR      r5,|L1.1964|
000528  2101              MOVS     r1,#1
00052a  350c              ADDS     r5,r5,#0xc
00052c  4628              MOV      r0,r5
00052e  f7fffffe          BL       swd_write_word
000532  2800              CMP      r0,#0
000534  d034              BEQ      |L1.1440|
;;;884                    return 0;
;;;885                }
;;;886    
;;;887                // Reset again
;;;888                swd_set_target_reset(1);
;;;889                Delayms(2);
000536  2002              MOVS     r0,#2
000538  f7fffffe          BL       Delayms
;;;890    
;;;891                swd_set_target_reset(0);
;;;892    #else            
;;;893                if (!swd_init_debug()) {
;;;894                    return 0;
;;;895                }
;;;896    
;;;897                // Enable debug and halt the core (DHCSR <- 0xA05F0003)
;;;898                if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN | C_HALT)) {
;;;899                    return 0;
;;;900                }
;;;901                
;;;902                // Wait until core is halted
;;;903                do {
;;;904                    if (!swd_read_word(DBG_HCSR, &val)) {
;;;905                        return 0;
;;;906                    }
;;;907                } while((val & S_HALT) == 0);
;;;908    
;;;909                // Enable halt on reset
;;;910                if (!swd_write_word(DBG_EMCR, VC_CORERESET)) {
;;;911                    return 0;
;;;912                }
;;;913    
;;;914    	        // Perform a soft reset
;;;915                if (!swd_write_word(NVIC_AIRCR, VECTKEY | SOFT_RESET)) {
;;;916                    return 0;
;;;917                }
;;;918    #endif
;;;919                Delayms(2);
00053c  2002              MOVS     r0,#2
00053e  f7fffffe          BL       Delayms
                  |L1.1346|
;;;920    
;;;921                do {
;;;922                    if (!swd_read_word(DBG_HCSR, &val)) {
000542  4669              MOV      r1,sp
000544  4620              MOV      r0,r4
000546  f7fffffe          BL       swd_read_word
00054a  2800              CMP      r0,#0
00054c  d028              BEQ      |L1.1440|
;;;923                        return 0;
;;;924                    }
;;;925                } while((val & S_HALT) == 0);
00054e  9800              LDR      r0,[sp,#0]
000550  0380              LSLS     r0,r0,#14
000552  d5f6              BPL      |L1.1346|
;;;926    
;;;927                // Disable halt on reset
;;;928                if (!swd_write_word(DBG_EMCR, 0)) {
000554  2100              MOVS     r1,#0
000556  4628              MOV      r0,r5
000558  e01d              B        |L1.1430|
;;;929                    return 0;
;;;930                }
;;;931    
;;;932                break;
;;;933    
;;;934            case NO_DEBUG:
;;;935                if (!swd_write_word(DBG_HCSR, DBGKEY)) {
00055a  4993              LDR      r1,|L1.1960|
00055c  1e49              SUBS     r1,r1,#1
00055e  e019              B        |L1.1428|
;;;936                    return 0;
;;;937                }
;;;938                break;
;;;939    
;;;940            case DEBUG:
;;;941                DAP_Setup();
000560  f7fffffe          BL       DAP_Setup
;;;942                PORT_SWD_SETUP();
;;;943    
;;;944                if (!JTAG2SWD()) {
000564  f7fffffe          BL       JTAG2SWD
000568  2800              CMP      r0,#0
00056a  d019              BEQ      |L1.1440|
;;;945                    return 0;
;;;946                }
;;;947    
;;;948                if (!swd_write_dp(DP_ABORT, STKCMPCLR | STKERRCLR | WDERRCLR | ORUNERRCLR)) {
00056c  211e              MOVS     r1,#0x1e
00056e  2000              MOVS     r0,#0
000570  f7fffffe          BL       swd_write_dp
000574  2800              CMP      r0,#0
000576  d013              BEQ      |L1.1440|
;;;949                    return 0;
;;;950                }
;;;951    
;;;952                // Ensure CTRL/STAT register selected in DPBANKSEL
;;;953                if (!swd_write_dp(DP_SELECT, 0)) {
000578  2100              MOVS     r1,#0
00057a  2008              MOVS     r0,#8
00057c  f7fffffe          BL       swd_write_dp
000580  2800              CMP      r0,#0
000582  d00d              BEQ      |L1.1440|
;;;954                    return 0;
;;;955                }
;;;956    
;;;957                // Power up
;;;958                if (!swd_write_dp(DP_CTRL_STAT, CSYSPWRUPREQ | CDBGPWRUPREQ)) {
000584  f04f41a0          MOV      r1,#0x50000000
000588  2004              MOVS     r0,#4
00058a  f7fffffe          BL       swd_write_dp
00058e  2800              CMP      r0,#0
000590  d006              BEQ      |L1.1440|
;;;959                    return 0;
;;;960                }
;;;961    
;;;962                // Enable debug (for semihost)
;;;963                if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN)) {
000592  4629              MOV      r1,r5
                  |L1.1428|
000594  4620              MOV      r0,r4
                  |L1.1430|
000596  f7fffffe          BL       swd_write_word
00059a  2800              CMP      r0,#0
00059c  d000              BEQ      |L1.1440|
                  |L1.1438|
;;;964                    return 0;
;;;965                }
;;;966    
;;;967                break;
;;;968    
;;;969            default:
;;;970                return 0;
;;;971        }
;;;972        return 1;
00059e  2001              MOVS     r0,#1
                  |L1.1440|
;;;973    }
0005a0  bd38              POP      {r3-r5,pc}
                  |L1.1442|
0005a2  2000              MOVS     r0,#0                 ;970
0005a4  bd38              POP      {r3-r5,pc}
                          ENDP

                  int2array PROC
;;;82     
;;;83     static void int2array(uint8_t * res, uint32_t data, uint8_t len) {
0005a6  b510              PUSH     {r4,lr}
;;;84         uint8_t i = 0;
0005a8  2300              MOVS     r3,#0
0005aa  e005              B        |L1.1464|
                  |L1.1452|
0005ac  00dc              LSLS     r4,r3,#3              ;83
;;;85         for (i = 0; i < len; i++) {
;;;86             res[i] = (data >> 8*i) & 0xff;
0005ae  fa21f404          LSR      r4,r1,r4
0005b2  54c4              STRB     r4,[r0,r3]
0005b4  1c5b              ADDS     r3,r3,#1              ;85
0005b6  b2db              UXTB     r3,r3                 ;85
                  |L1.1464|
0005b8  4293              CMP      r3,r2                 ;85
0005ba  d3f7              BCC      |L1.1452|
;;;87         }
;;;88     }
0005bc  bd10              POP      {r4,pc}
;;;89     
                          ENDP

                  swd_transfer_retry PROC
;;;90     static uint8_t swd_transfer_retry(uint32_t req, uint32_t * data) {
0005be  b570              PUSH     {r4-r6,lr}
0005c0  460d              MOV      r5,r1
0005c2  4606              MOV      r6,r0
;;;91         uint8_t i, ack;
;;;92         for (i = 0; i < MAX_SWD_RETRY; i++) {
0005c4  2400              MOVS     r4,#0
                  |L1.1478|
;;;93             ack = SWD_Transfer(req, data);
0005c6  4629              MOV      r1,r5
0005c8  4630              MOV      r0,r6
0005ca  f7fffffe          BL       SWD_Transfer
;;;94             // if ack != WAIT
;;;95             if (ack != 0x02) {
0005ce  2802              CMP      r0,#2
0005d0  d103              BNE      |L1.1498|
0005d2  1c64              ADDS     r4,r4,#1              ;92
0005d4  b2e4              UXTB     r4,r4                 ;92
0005d6  2c0a              CMP      r4,#0xa               ;92
0005d8  d3f5              BCC      |L1.1478|
                  |L1.1498|
;;;96                 return ack;
;;;97             }
;;;98         }
;;;99         return ack;
;;;100    }
0005da  bd70              POP      {r4-r6,pc}
;;;101    
                          ENDP

                  swd_write_block PROC
;;;206    // size is in bytes.
;;;207    static uint8_t swd_write_block(uint32_t address, uint8_t *data, uint32_t size) {
0005dc  b5f8              PUSH     {r3-r7,lr}
0005de  460d              MOV      r5,r1
0005e0  4604              MOV      r4,r0
0005e2  b32a              CBZ      r2,|L1.1584|
;;;208        uint8_t tmp_in[4], req;
;;;209        uint32_t size_in_words;
;;;210        uint32_t i, ack;
;;;211    
;;;212        if (size==0)
;;;213            return 0;
;;;214    
;;;215        size_in_words = size/4;
0005e4  0896              LSRS     r6,r2,#2
;;;216    
;;;217        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
0005e6  4972              LDR      r1,|L1.1968|
0005e8  2000              MOVS     r0,#0
0005ea  f7fffffe          BL       swd_write_ap
0005ee  2800              CMP      r0,#0
0005f0  d01f              BEQ      |L1.1586|
;;;218            return 0;
;;;219        }
;;;220    
;;;221        // TAR write
;;;222        req = SWD_REG_AP | SWD_REG_W | (1 << 2);
0005f2  2705              MOVS     r7,#5
;;;223        int2array(tmp_in, address, 4);
0005f4  2204              MOVS     r2,#4
0005f6  4621              MOV      r1,r4
0005f8  4668              MOV      r0,sp
0005fa  f7fffffe          BL       int2array
;;;224        if (swd_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
0005fe  4669              MOV      r1,sp
000600  4638              MOV      r0,r7
000602  f7fffffe          BL       swd_transfer_retry
000606  2801              CMP      r0,#1
000608  d112              BNE      |L1.1584|
;;;225            return 0;
;;;226        }
;;;227    
;;;228        // DRW write
;;;229        req = SWD_REG_AP | SWD_REG_W | (3 << 2);
00060a  270d              MOVS     r7,#0xd
;;;230        for (i = 0; i < size_in_words; i++) {
00060c  2400              MOVS     r4,#0
00060e  e007              B        |L1.1568|
                  |L1.1552|
;;;231            if (swd_transfer_retry(req, (uint32_t *)data) != 0x01) {
000610  4629              MOV      r1,r5
000612  4638              MOV      r0,r7
000614  f7fffffe          BL       swd_transfer_retry
000618  2801              CMP      r0,#1
00061a  d109              BNE      |L1.1584|
;;;232                return 0;
;;;233            }
;;;234            data+=4;
00061c  1d2d              ADDS     r5,r5,#4
00061e  1c64              ADDS     r4,r4,#1              ;230
                  |L1.1568|
000620  42b4              CMP      r4,r6                 ;230
000622  d3f5              BCC      |L1.1552|
;;;235        }
;;;236    
;;;237        // dummy read
;;;238        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
000624  200e              MOVS     r0,#0xe
;;;239        ack = swd_transfer_retry(req, NULL);
000626  2100              MOVS     r1,#0
000628  f7fffffe          BL       swd_transfer_retry
;;;240    
;;;241        return (ack == 0x01);
00062c  2801              CMP      r0,#1
00062e  d000              BEQ      |L1.1586|
                  |L1.1584|
000630  2000              MOVS     r0,#0
                  |L1.1586|
;;;242    }
000632  bdf8              POP      {r3-r7,pc}
;;;243    
                          ENDP

                  swd_read_block PROC
;;;245    // size is in bytes.
;;;246    static uint8_t swd_read_block(uint32_t address, uint8_t *data, uint32_t size) {
000634  b5f8              PUSH     {r3-r7,lr}
000636  460d              MOV      r5,r1
000638  4604              MOV      r4,r0
00063a  b35a              CBZ      r2,|L1.1684|
;;;247        uint8_t tmp_in[4], req, ack;
;;;248        uint32_t size_in_words;
;;;249        uint32_t i;
;;;250    
;;;251        if (size == 0) {
;;;252            return 0;
;;;253        }
;;;254    
;;;255        size_in_words = size/4;
00063c  0896              LSRS     r6,r2,#2
;;;256    
;;;257        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
00063e  495c              LDR      r1,|L1.1968|
000640  2000              MOVS     r0,#0
000642  f7fffffe          BL       swd_write_ap
000646  2800              CMP      r0,#0
000648  d025              BEQ      |L1.1686|
;;;258            return 0;
;;;259        }
;;;260    
;;;261        // TAR write
;;;262        req = SWD_REG_AP | SWD_REG_W | (1 << 2);
00064a  2705              MOVS     r7,#5
;;;263        int2array(tmp_in, address, 4);
00064c  2204              MOVS     r2,#4
00064e  4621              MOV      r1,r4
000650  4668              MOV      r0,sp
000652  f7fffffe          BL       int2array
;;;264        if (swd_transfer_retry(req, (uint32_t *)tmp_in) != 0x01) {
000656  4669              MOV      r1,sp
000658  4638              MOV      r0,r7
00065a  f7fffffe          BL       swd_transfer_retry
00065e  2801              CMP      r0,#1
000660  d118              BNE      |L1.1684|
;;;265            return 0;
;;;266        }
;;;267    
;;;268        // read data
;;;269        req = SWD_REG_AP | SWD_REG_R | (3 << 2);
000662  270f              MOVS     r7,#0xf
;;;270        // dummy read
;;;271        if (swd_transfer_retry(req, (uint32_t *)data) != 0x01) {
000664  4629              MOV      r1,r5
000666  4638              MOV      r0,r7
000668  f7fffffe          BL       swd_transfer_retry
00066c  2801              CMP      r0,#1
00066e  d111              BNE      |L1.1684|
;;;272            return 0;
;;;273        }
;;;274    
;;;275        for (i = 0; i< size_in_words; i++) {
000670  2400              MOVS     r4,#0
000672  e007              B        |L1.1668|
                  |L1.1652|
;;;276            if (swd_transfer_retry(req, (uint32_t *)data) != 0x01) {
000674  4629              MOV      r1,r5
000676  4638              MOV      r0,r7
000678  f7fffffe          BL       swd_transfer_retry
00067c  2801              CMP      r0,#1
00067e  d109              BNE      |L1.1684|
;;;277                return 0;
;;;278            }
;;;279            data += 4;
000680  1d2d              ADDS     r5,r5,#4
000682  1c64              ADDS     r4,r4,#1              ;275
                  |L1.1668|
000684  42b4              CMP      r4,r6                 ;275
000686  d3f5              BCC      |L1.1652|
;;;280        }
;;;281    
;;;282        // dummy read
;;;283        req = SWD_REG_DP | SWD_REG_R | SWD_REG_ADR(DP_RDBUFF);
000688  200e              MOVS     r0,#0xe
;;;284        ack = swd_transfer_retry(req, NULL);
00068a  2100              MOVS     r1,#0
00068c  f7fffffe          BL       swd_transfer_retry
;;;285    
;;;286        return (ack == 0x01);
000690  2801              CMP      r0,#1
000692  d000              BEQ      |L1.1686|
                  |L1.1684|
000694  2000              MOVS     r0,#0
                  |L1.1686|
;;;287    }
000696  bdf8              POP      {r3-r7,pc}
;;;288    
                          ENDP

                  swd_read_word PROC
;;;343    // Read 32-bit word from target memory.
;;;344    static uint8_t swd_read_word(uint32_t addr, uint32_t *val) {
000698  b570              PUSH     {r4-r6,lr}
00069a  460c              MOV      r4,r1
00069c  4605              MOV      r5,r0
;;;345        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
00069e  4944              LDR      r1,|L1.1968|
0006a0  2000              MOVS     r0,#0
0006a2  f7fffffe          BL       swd_write_ap
0006a6  2800              CMP      r0,#0
0006a8  d006              BEQ      |L1.1720|
;;;346            return 0;
;;;347        }
;;;348    
;;;349        if (!swd_read_data(addr, val)) {
0006aa  4621              MOV      r1,r4
0006ac  4628              MOV      r0,r5
0006ae  f7fffffe          BL       swd_read_data
0006b2  2800              CMP      r0,#0
0006b4  d000              BEQ      |L1.1720|
;;;350            return 0;
;;;351        }
;;;352    
;;;353        return 1;
0006b6  2001              MOVS     r0,#1
                  |L1.1720|
;;;354    }
0006b8  bd70              POP      {r4-r6,pc}
;;;355    
                          ENDP

                  swd_write_word PROC
;;;356    // Write 32-bit word to target memory.
;;;357    static uint8_t swd_write_word(uint32_t addr, uint32_t val) {
0006ba  b570              PUSH     {r4-r6,lr}
0006bc  460c              MOV      r4,r1
0006be  4605              MOV      r5,r0
;;;358        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE32)) {
0006c0  493b              LDR      r1,|L1.1968|
0006c2  2000              MOVS     r0,#0
0006c4  f7fffffe          BL       swd_write_ap
0006c8  2800              CMP      r0,#0
0006ca  d006              BEQ      |L1.1754|
;;;359            return 0;
;;;360        }
;;;361    
;;;362        if (!swd_write_data(addr, val)) {
0006cc  4621              MOV      r1,r4
0006ce  4628              MOV      r0,r5
0006d0  f7fffffe          BL       swd_write_data
0006d4  2800              CMP      r0,#0
0006d6  d000              BEQ      |L1.1754|
;;;363            return 0;
;;;364        }
;;;365    
;;;366        return 1;
0006d8  2001              MOVS     r0,#1
                  |L1.1754|
;;;367    }
0006da  bd70              POP      {r4-r6,pc}
;;;368    
                          ENDP

                  swd_write_byte PROC
;;;384    // Write 8-bit byte to target memory.
;;;385    static uint8_t swd_write_byte(uint32_t addr, uint8_t val) {
0006dc  b570              PUSH     {r4-r6,lr}
0006de  460c              MOV      r4,r1
;;;386        uint32_t tmp;
;;;387    
;;;388        if (!swd_write_ap(AP_CSW, CSW_VALUE | CSW_SIZE8)) {
0006e0  4933              LDR      r1,|L1.1968|
0006e2  4605              MOV      r5,r0                 ;385
0006e4  1e89              SUBS     r1,r1,#2
0006e6  2000              MOVS     r0,#0
0006e8  f7fffffe          BL       swd_write_ap
0006ec  2800              CMP      r0,#0
0006ee  d009              BEQ      |L1.1796|
;;;389            return 0;
;;;390        }
;;;391    
;;;392        tmp = val << ((addr & 0x03) << 3);
0006f0  07a8              LSLS     r0,r5,#30
0006f2  0ec0              LSRS     r0,r0,#27
0006f4  fa04f100          LSL      r1,r4,r0
;;;393        if (!swd_write_data(addr, tmp)) {
0006f8  4628              MOV      r0,r5
0006fa  f7fffffe          BL       swd_write_data
0006fe  2800              CMP      r0,#0
000700  d000              BEQ      |L1.1796|
;;;394            return 0;
;;;395        }
;;;396    
;;;397        return 1;
000702  2001              MOVS     r0,#1
                  |L1.1796|
;;;398    }
000704  bd70              POP      {r4-r6,pc}
;;;399    
                          ENDP

                  swd_write_debug_state PROC
;;;489    // Execute system call.
;;;490    static uint8_t swd_write_debug_state(DEBUG_STATE *state) {
000706  b538              PUSH     {r3-r5,lr}
000708  4605              MOV      r5,r0
;;;491        uint32_t i, status;
;;;492    
;;;493        if (!swd_write_dp(DP_SELECT, 0)) {
00070a  2100              MOVS     r1,#0
00070c  2008              MOVS     r0,#8
00070e  f7fffffe          BL       swd_write_dp
000712  2800              CMP      r0,#0
000714  d033              BEQ      |L1.1918|
;;;494            return 0;
;;;495        }
;;;496    
;;;497        // R0, R1, R2, R3
;;;498        for (i = 0; i < 4; i++) {
000716  2400              MOVS     r4,#0
                  |L1.1816|
;;;499            if (!swd_write_core_register(i, state->r[i])) {
000718  4620              MOV      r0,r4
00071a  f8551024          LDR      r1,[r5,r4,LSL #2]
00071e  f7fffffe          BL       swd_write_core_register
000722  2800              CMP      r0,#0
000724  d02b              BEQ      |L1.1918|
000726  1c64              ADDS     r4,r4,#1              ;498
000728  2c04              CMP      r4,#4                 ;498
00072a  d3f5              BCC      |L1.1816|
;;;500                return 0;
;;;501            }
;;;502        }
;;;503    
;;;504        // R9
;;;505        if (!swd_write_core_register(9, state->r[9])) {
00072c  2009              MOVS     r0,#9
00072e  6a69              LDR      r1,[r5,#0x24]
000730  f7fffffe          BL       swd_write_core_register
000734  2800              CMP      r0,#0
000736  d022              BEQ      |L1.1918|
;;;506            return 0;
;;;507        }
;;;508    
;;;509        // R13, R14, R15
;;;510        for (i=13; i<16; i++) {
000738  f05f040d          MOVS.W   r4,#0xd
                  |L1.1852|
;;;511            if (!swd_write_core_register(i, state->r[i])) {
00073c  4620              MOV      r0,r4
00073e  f8551024          LDR      r1,[r5,r4,LSL #2]
000742  f7fffffe          BL       swd_write_core_register
000746  2800              CMP      r0,#0
000748  d019              BEQ      |L1.1918|
00074a  1c64              ADDS     r4,r4,#1              ;510
00074c  2c10              CMP      r4,#0x10              ;510
00074e  d3f5              BCC      |L1.1852|
;;;512                return 0;
;;;513            }
;;;514        }
;;;515    
;;;516        // xPSR
;;;517        if (!swd_write_core_register(16, state->xpsr)) {
000750  2010              MOVS     r0,#0x10
000752  6c29              LDR      r1,[r5,#0x40]
000754  f7fffffe          BL       swd_write_core_register
000758  2800              CMP      r0,#0
00075a  d010              BEQ      |L1.1918|
;;;518            return 0;
;;;519        }
;;;520    
;;;521        if (!swd_write_word(DBG_HCSR, DBGKEY | C_DEBUGEN)) {
00075c  4912              LDR      r1,|L1.1960|
00075e  4813              LDR      r0,|L1.1964|
000760  f7fffffe          BL       swd_write_word
000764  2800              CMP      r0,#0
000766  d00a              BEQ      |L1.1918|
;;;522            return 0;
;;;523        }
;;;524    
;;;525        // check status
;;;526        if (!swd_read_dp(DP_CTRL_STAT, &status)){
000768  4669              MOV      r1,sp
00076a  2004              MOVS     r0,#4
00076c  f7fffffe          BL       swd_read_dp
000770  2800              CMP      r0,#0
000772  d004              BEQ      |L1.1918|
;;;527            return 0;
;;;528        }
;;;529    
;;;530        if (status & (STICKYERR | WDATAERR)) {
000774  9800              LDR      r0,[sp,#0]
000776  f0100fa0          TST      r0,#0xa0
00077a  d001              BEQ      |L1.1920|
;;;531            return 0;
00077c  2000              MOVS     r0,#0
                  |L1.1918|
;;;532        }
;;;533    
;;;534        return 1;
;;;535    }
00077e  bd38              POP      {r3-r5,pc}
                  |L1.1920|
000780  2001              MOVS     r0,#1                 ;534
000782  bd38              POP      {r3-r5,pc}
;;;536    
                          ENDP

                  swd_reset PROC
;;;693    // SWD Reset
;;;694    static uint8_t swd_reset(void) {
000784  b51c              PUSH     {r2-r4,lr}
;;;695        uint8_t tmp_in[8];
;;;696        uint8_t i = 0;
000786  2000              MOVS     r0,#0
000788  4669              MOV      r1,sp                 ;695
;;;697        for (i = 0; i < 8; i++) {
;;;698            tmp_in[i] = 0xff;
00078a  22ff              MOVS     r2,#0xff
                  |L1.1932|
00078c  540a              STRB     r2,[r1,r0]
00078e  1c40              ADDS     r0,r0,#1              ;697
000790  b2c0              UXTB     r0,r0                 ;697
000792  2808              CMP      r0,#8                 ;697
000794  d3fa              BCC      |L1.1932|
;;;699        }
;;;700    
;;;701        SWJ_Sequence(51, tmp_in);
000796  2033              MOVS     r0,#0x33
000798  f7fffffe          BL       SWJ_Sequence
;;;702    
;;;703        return 1;
00079c  2001              MOVS     r0,#1
;;;704    }
00079e  bd1c              POP      {r2-r4,pc}
;;;705    
                          ENDP

                  |L1.1952|
                          DCD      ||.data||
                  |L1.1956|
                          DCD      0x50000f00
                  |L1.1960|
                          DCD      0xa05f0001
                  |L1.1964|
                          DCD      0xe000edf0
                  |L1.1968|
                          DCD      0x23000052

                          AREA ||.data||, DATA, ALIGN=2

                  dap_state
                          %        8

;*** Start embedded assembler ***

#line 1 "app\\swd_host.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_swd_host_c_swd_init____REV16|
#line 129 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_swd_host_c_swd_init____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_swd_host_c_swd_init____REVSH|
#line 144
|__asm___10_swd_host_c_swd_init____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
