; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\obj\usbd_user_hid.o --asm_dir=.\Lst\ --list_dir=.\Lst\ --depend=.\obj\usbd_user_hid.d --cpu=Cortex-M3 --apcs=interwork -O3 -I.\app -I.\USBStack\INC -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\NXP\LPC18xx -D__MICROLIB --omf_browse=.\obj\usbd_user_hid.crf app\usbd_user_hid.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  usbd_hid_init PROC
;;;45     // USB HID Callback: when system initializes
;;;46     void usbd_hid_init (void) {
000000  484a              LDR      r0,|L1.300|
;;;47       USB_RequestFlag   = 0;
000002  2100              MOVS     r1,#0
000004  7001              STRB     r1,[r0,#0]
;;;48       USB_RequestIn     = 0;
000006  6041              STR      r1,[r0,#4]  ; USB_RequestIn
;;;49       USB_RequestOut    = 0;
000008  6081              STR      r1,[r0,#8]  ; USB_RequestOut
;;;50       USB_ResponseIdle  = 1;
00000a  2201              MOVS     r2,#1
00000c  7042              STRB     r2,[r0,#1]
;;;51       USB_ResponseFlag  = 0;
00000e  7081              STRB     r1,[r0,#2]
;;;52       USB_ResponseIn    = 0;
000010  60c1              STR      r1,[r0,#0xc]  ; USB_ResponseIn
;;;53       USB_ResponseOut   = 0;
000012  6101              STR      r1,[r0,#0x10]  ; USB_ResponseOut
;;;54     }
000014  4770              BX       lr
;;;55     
                          ENDP

                  usbd_hid_get_report PROC
;;;56     // USB HID Callback: when data needs to be prepared for the host
;;;57     int usbd_hid_get_report (uint8_t rtype, uint8_t rid, uint8_t *buf, uint8_t req) {
000016  b570              PUSH     {r4-r6,lr}
000018  4615              MOV      r5,r2
;;;58     
;;;59       switch (rtype) {
00001a  2801              CMP      r0,#1
00001c  d122              BNE      |L1.100|
;;;60         case HID_REPORT_INPUT:
;;;61           switch (req) {
00001e  b30b              CBZ      r3,|L1.100|
000020  2b01              CMP      r3,#1
000022  d11f              BNE      |L1.100|
;;;62             case USBD_HID_REQ_EP_CTRL:
;;;63             case USBD_HID_REQ_PERIOD_UPDATE:
;;;64               break;
;;;65             case USBD_HID_REQ_EP_INT:
;;;66     
;;;67               if ((USB_ResponseOut != USB_ResponseIn) || USB_ResponseFlag) {
000024  4c41              LDR      r4,|L1.300|
000026  6920              LDR      r0,[r4,#0x10]  ; USB_ResponseOut
000028  68e1              LDR      r1,[r4,#0xc]  ; USB_ResponseIn
00002a  4288              CMP      r0,r1
00002c  d101              BNE      |L1.50|
00002e  78a0              LDRB     r0,[r4,#2]  ; USB_ResponseFlag
000030  b1b0              CBZ      r0,|L1.96|
                  |L1.50|
;;;68                 memcpy(buf, USB_Response[USB_ResponseOut], DAP_PACKET_SIZE);
000032  483f              LDR      r0,|L1.304|
000034  6921              LDR      r1,[r4,#0x10]  ; USB_ResponseOut
000036  2240              MOVS     r2,#0x40
000038  eb001181          ADD      r1,r0,r1,LSL #6
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       __aeabi_memcpy
;;;69                 USB_ResponseOut++;
000042  6920              LDR      r0,[r4,#0x10]  ; USB_ResponseOut
000044  1c40              ADDS     r0,r0,#1
000046  6120              STR      r0,[r4,#0x10]  ; USB_ResponseOut
;;;70                 if (USB_ResponseOut == DAP_PACKET_COUNT) {
000048  6921              LDR      r1,[r4,#0x10]  ; USB_ResponseOut
00004a  2000              MOVS     r0,#0
00004c  2940              CMP      r1,#0x40
00004e  d100              BNE      |L1.82|
;;;71                   USB_ResponseOut = 0;
000050  6120              STR      r0,[r4,#0x10]  ; USB_ResponseOut
                  |L1.82|
;;;72                 }
;;;73                 if (USB_ResponseOut == USB_ResponseIn) {
000052  6921              LDR      r1,[r4,#0x10]  ; USB_ResponseOut
000054  68e2              LDR      r2,[r4,#0xc]  ; USB_ResponseIn
000056  4291              CMP      r1,r2
000058  d100              BNE      |L1.92|
;;;74                   USB_ResponseFlag = 0;
00005a  70a0              STRB     r0,[r4,#2]
                  |L1.92|
;;;75                 }
;;;76                 return (DAP_PACKET_SIZE);
00005c  2040              MOVS     r0,#0x40
;;;77               } else {
;;;78                 USB_ResponseIdle = 1;
;;;79               }
;;;80               break;
;;;81           }
;;;82           break;
;;;83         case HID_REPORT_FEATURE:
;;;84           break;
;;;85       }
;;;86       return (0);
;;;87     }
00005e  bd70              POP      {r4-r6,pc}
                  |L1.96|
000060  2001              MOVS     r0,#1                 ;78
000062  7060              STRB     r0,[r4,#1]            ;78
                  |L1.100|
000064  2000              MOVS     r0,#0                 ;86
000066  bd70              POP      {r4-r6,pc}
;;;88     
                          ENDP

                  usbd_hid_set_report PROC
;;;89     // USB HID Callback: when data is received from the host
;;;90     void usbd_hid_set_report (uint8_t rtype, uint8_t rid, uint8_t *buf, int len, uint8_t req) {
000068  b570              PUSH     {r4-r6,lr}
00006a  4611              MOV      r1,r2
;;;91     
;;;92       switch (rtype) {
00006c  2802              CMP      r0,#2
00006e  d11c              BNE      |L1.170|
;;;93         case HID_REPORT_OUTPUT:
;;;94     
;;;95           if (len == 0) break;
000070  2b00              CMP      r3,#0
000072  d01a              BEQ      |L1.170|
;;;96           if (buf[0] == ID_DAP_TransferAbort) {
000074  7808              LDRB     r0,[r1,#0]
;;;97             DAP_TransferAbort = 1;
000076  2501              MOVS     r5,#1
000078  2807              CMP      r0,#7                 ;96
00007a  d014              BEQ      |L1.166|
;;;98             break;
;;;99           }
;;;100          if (USB_RequestFlag && (USB_RequestIn == USB_RequestOut)) {
00007c  4c2b              LDR      r4,|L1.300|
00007e  7820              LDRB     r0,[r4,#0]  ; USB_RequestFlag
000080  b118              CBZ      r0,|L1.138|
000082  6860              LDR      r0,[r4,#4]  ; USB_RequestIn
000084  68a2              LDR      r2,[r4,#8]  ; USB_RequestOut
000086  4290              CMP      r0,r2
000088  d00f              BEQ      |L1.170|
                  |L1.138|
;;;101            break;  // Discard packet when buffer is full
;;;102          }
;;;103          // Store data into request packet buffer
;;;104          memcpy(USB_Request[USB_RequestIn], buf, len);
00008a  482a              LDR      r0,|L1.308|
00008c  6862              LDR      r2,[r4,#4]  ; USB_RequestIn
00008e  eb001082          ADD      r0,r0,r2,LSL #6
000092  461a              MOV      r2,r3
000094  f7fffffe          BL       __aeabi_memcpy
;;;105    
;;;106          USB_RequestIn++;
000098  6860              LDR      r0,[r4,#4]  ; USB_RequestIn
00009a  1c40              ADDS     r0,r0,#1
00009c  6060              STR      r0,[r4,#4]  ; USB_RequestIn
;;;107          if (USB_RequestIn == DAP_PACKET_COUNT) {
00009e  6860              LDR      r0,[r4,#4]  ; USB_RequestIn
0000a0  2840              CMP      r0,#0x40
0000a2  d003              BEQ      |L1.172|
0000a4  e004              B        |L1.176|
                  |L1.166|
0000a6  4824              LDR      r0,|L1.312|
0000a8  7005              STRB     r5,[r0,#0]            ;97
                  |L1.170|
;;;108            USB_RequestIn = 0;
;;;109          }
;;;110          if (USB_RequestIn == USB_RequestOut) {
;;;111            USB_RequestFlag = 1;
;;;112          }
;;;113          break;
;;;114        case HID_REPORT_FEATURE:
;;;115          break;
;;;116      }
;;;117    }
0000aa  bd70              POP      {r4-r6,pc}
                  |L1.172|
0000ac  2000              MOVS     r0,#0                 ;108
0000ae  6060              STR      r0,[r4,#4]            ;108  ; USB_RequestIn
                  |L1.176|
0000b0  6860              LDR      r0,[r4,#4]            ;110  ; USB_RequestIn
0000b2  68a1              LDR      r1,[r4,#8]            ;110  ; USB_RequestOut
0000b4  4288              CMP      r0,r1                 ;110
0000b6  d1f8              BNE      |L1.170|
0000b8  7025              STRB     r5,[r4,#0]            ;111
0000ba  bd70              POP      {r4-r6,pc}
;;;118    
                          ENDP

                  usbd_hid_process PROC
;;;119    // Process USB HID Data
;;;120    void usbd_hid_process (void) {
0000bc  b570              PUSH     {r4-r6,lr}
0000be  2600              MOVS     r6,#0
;;;121      uint32_t n;
;;;122    //  usbd_hid_init();
;;;123    
;;;124      // Process pending requests
;;;125      while ((USB_RequestOut != USB_RequestIn) || USB_RequestFlag) { /*当USB_RequestOut != USB_RequestIn，说明有未完成的请求，或者当USB_RequestFlag=1时，有未完成的请求*/
;;;126          // Process DAP Command and prepare response
;;;127    
;;;128          DAP_ProcessCommand(USB_Request[USB_RequestOut], USB_Response[USB_ResponseIn]);
0000c0  4d1b              LDR      r5,|L1.304|
0000c2  4c1a              LDR      r4,|L1.300|
0000c4  e029              B        |L1.282|
                  |L1.198|
0000c6  68e0              LDR      r0,[r4,#0xc]  ; USB_ResponseIn
0000c8  68a2              LDR      r2,[r4,#8]  ; USB_RequestOut
0000ca  eb051180          ADD      r1,r5,r0,LSL #6
0000ce  4819              LDR      r0,|L1.308|
0000d0  eb001082          ADD      r0,r0,r2,LSL #6
0000d4  f7fffffe          BL       DAP_ProcessCommand
;;;129    
;;;130          // Update request index and flag
;;;131          USB_RequestOut = (USB_RequestOut +1) % DAP_PACKET_COUNT;
0000d8  68a0              LDR      r0,[r4,#8]  ; USB_RequestOut
0000da  1c40              ADDS     r0,r0,#1
0000dc  f000003f          AND      r0,r0,#0x3f
0000e0  60a0              STR      r0,[r4,#8]  ; USB_RequestOut
;;;132          if (USB_RequestOut == USB_RequestIn) {
0000e2  68a0              LDR      r0,[r4,#8]  ; USB_RequestOut
0000e4  6861              LDR      r1,[r4,#4]  ; USB_RequestIn
0000e6  4288              CMP      r0,r1
0000e8  d100              BNE      |L1.236|
;;;133              USB_RequestFlag = 0;
0000ea  7026              STRB     r6,[r4,#0]
                  |L1.236|
;;;134          }
;;;135    
;;;136          if (USB_ResponseIdle) {
0000ec  7860              LDRB     r0,[r4,#1]  ; USB_ResponseIdle
0000ee  b140              CBZ      r0,|L1.258|
;;;137              // Request that data is send back to host
;;;138              USB_ResponseIdle = 0;
0000f0  7066              STRB     r6,[r4,#1]
;;;139              usbd_hid_get_report_trigger(0, USB_Response[USB_ResponseIn], DAP_PACKET_SIZE);
0000f2  68e0              LDR      r0,[r4,#0xc]  ; USB_ResponseIn
0000f4  2240              MOVS     r2,#0x40
0000f6  eb051180          ADD      r1,r5,r0,LSL #6
0000fa  2000              MOVS     r0,#0
0000fc  f7fffffe          BL       usbd_hid_get_report_trigger
000100  e00b              B        |L1.282|
                  |L1.258|
;;;140          } else {
;;;141              // Update response index and flag
;;;142              n = USB_ResponseIn + 1;
000102  68e0              LDR      r0,[r4,#0xc]  ; USB_ResponseIn
000104  1c40              ADDS     r0,r0,#1
;;;143              if (n == DAP_PACKET_COUNT) {
000106  2840              CMP      r0,#0x40
000108  d100              BNE      |L1.268|
;;;144                  n = 0;
00010a  2000              MOVS     r0,#0
                  |L1.268|
;;;145              }
;;;146              USB_ResponseIn = n;
00010c  60e0              STR      r0,[r4,#0xc]  ; USB_ResponseIn
;;;147              if (USB_ResponseIn == USB_ResponseOut) {
00010e  68e0              LDR      r0,[r4,#0xc]  ; USB_ResponseIn
000110  6921              LDR      r1,[r4,#0x10]  ; USB_ResponseOut
000112  4288              CMP      r0,r1
000114  d101              BNE      |L1.282|
;;;148                  USB_ResponseFlag = 1;
000116  2001              MOVS     r0,#1
000118  70a0              STRB     r0,[r4,#2]
                  |L1.282|
00011a  68a0              LDR      r0,[r4,#8]            ;125  ; USB_RequestOut
00011c  6861              LDR      r1,[r4,#4]            ;125  ; USB_RequestIn
00011e  4288              CMP      r0,r1                 ;125
000120  d1d1              BNE      |L1.198|
000122  7820              LDRB     r0,[r4,#0]            ;125  ; USB_RequestFlag
000124  2800              CMP      r0,#0                 ;125
000126  d1ce              BNE      |L1.198|
;;;149              }
;;;150          }
;;;151      }
;;;152    }
000128  bd70              POP      {r4-r6,pc}
                          ENDP

00012a  0000              DCW      0x0000
                  |L1.300|
                          DCD      ||.data||
                  |L1.304|
                          DCD      ||.bss||+0x1000
                  |L1.308|
                          DCD      ||.bss||
                  |L1.312|
                          DCD      DAP_TransferAbort

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USB_Request
                          %        4096
                  USB_Response
                          %        4096

                          AREA ||.data||, DATA, ALIGN=2

                  USB_RequestFlag
000000  00                DCB      0x00
                  USB_ResponseIdle
000001  00                DCB      0x00
                  USB_ResponseFlag
000002  0000              DCB      0x00,0x00
                  USB_RequestIn
                          DCD      0x00000000
                  USB_RequestOut
                          DCD      0x00000000
                  USB_ResponseIn
                          DCD      0x00000000
                  USB_ResponseOut
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "app\\usbd_user_hid.c"
	AREA ||.rev16_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_usbd_user_hid_c_55124343____REV16|
#line 130 "C:\\Keil\\ARM\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_usbd_user_hid_c_55124343____REV16| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_usbd_user_hid_c_55124343____REVSH|
#line 145
|__asm___15_usbd_user_hid_c_55124343____REVSH| PROC
#line 146

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
